name: AI Worker Agent

on:
    workflow_dispatch:
        inputs:
            issue_number:
                description: "Issue number to execute"
                required: true

permissions:
    contents: write
    pull-requests: write
    issues: write
    repository-projects: write

jobs:
    work:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: "24"
                  cache: "npm"

            - name: Install uv (for MCP tools)
              uses: astral-sh/setup-uv@v5
              with:
                  enable-cache: false

            - name: Install dependencies
              run: npm ci || npm install

            - name: Generate AI Rules
              run: npx rulesync generate

            # 0. PREPARE CONTEXT
            - name: Fetch Issue Details
              id: issue
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
              run: |
                  gh issue view ${{ github.event.inputs.issue_number }} --json title,body,comments > issue.json
                  echo "title=$(jq -r .title issue.json)" >> $GITHUB_OUTPUT
                  # Handle multiline body safely with random delimiter
                  delimiter="$(openssl rand -hex 8)"
                  echo "body<<$delimiter" >> $GITHUB_OUTPUT
                  jq -r .body issue.json >> $GITHUB_OUTPUT
                  echo "$delimiter" >> $GITHUB_OUTPUT
                  # Extract issue comments
                  comments_delimiter="$(openssl rand -hex 8)"
                  echo "comments<<$comments_delimiter" >> $GITHUB_OUTPUT
                  jq -r '[.comments[] | "\(.author.login): \(.body)"] | join("\n---\n")' issue.json >> $GITHUB_OUTPUT
                  echo "$comments_delimiter" >> $GITHUB_OUTPUT

            - name: Fetch Pull Request Details
              id: pr
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
              run: |
                  # Find PR associated with this issue
                  PR_NUMBER=$(gh pr list --search "issue:$ISSUE_NUMBER" --json number --jq '.[0].number' 2>/dev/null || echo "")
                  
                  if [ -n "$PR_NUMBER" ]; then
                    echo "Found PR #$PR_NUMBER for Issue #$ISSUE_NUMBER"
                    echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
                    
                    # Fetch PR review comments and reviews
                    delimiter="$(openssl rand -hex 8)"
                    echo "pr_comments<<$delimiter" >> $GITHUB_OUTPUT
                    gh pr view "$PR_NUMBER" --json comments,reviews --jq '([.reviews[] | "Review (\(.state)): \(.body)"] + [.comments[] | "Comment by \(.author.login): \(.body)"]) | join("\n---\n")' >> $GITHUB_OUTPUT
                    echo "$delimiter" >> $GITHUB_OUTPUT
                  else
                    echo "No PR found for Issue #$ISSUE_NUMBER"
                    echo "pr_number=" >> $GITHUB_OUTPUT
                    echo "pr_comments=" >> $GITHUB_OUTPUT
                  fi

            - name: Debug Context
              env:
                  ISSUE_TITLE: ${{ steps.issue.outputs.title }}
              run: |
                  echo "Title: $ISSUE_TITLE"
                  echo "Body length: ${{ steps.issue.outputs.body }}" | wc -c

            - name: Set Task to In Progress
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
              run: |
                  # Project ID: PVT_kwHOAA562c4BOtC- (number 2)
                  # Status field ID: PVTSSF_lAHOAA562c4BOtC-zg9U7KE
                  # 'In progress' option ID: 47fc9ee4
                  
                  echo "Checking if Issue #$ISSUE_NUMBER is in Project #2..."
                  ITEM_ID=$(gh project item-list 2 --owner jorgecasar --format json | jq -r ".items[] | select(.content.number == ($ISSUE_NUMBER | tonumber)) | .id")
                  
                  if [ -z "$ITEM_ID" ] || [ "$ITEM_ID" == "null" ]; then
                    echo "Issue #$ISSUE_NUMBER not found in project. Adding it now..."
                    # We need the node_id of the issue to add it
                    ISSUE_NODE_ID=$(gh issue view $ISSUE_NUMBER --json id --jq .id)
                    ITEM_ID=$(gh project item-add 2 --owner jorgecasar --target-id "$ISSUE_NODE_ID" --format json | jq -r '.id')
                  fi

                  if [ -n "$ITEM_ID" ] && [ "$ITEM_ID" != "null" ]; then
                    echo "Setting Item $ITEM_ID to 'In progress'..."
                    gh project item-edit --id "$ITEM_ID" --project-id PVT_kwHOAA562c4BOtC- --field-id PVTSSF_lAHOAA562c4BOtC-zg9U7KE --single-select-option-id 47fc9ee4
                  else
                    echo "Failed to identify or add Issue #$ISSUE_NUMBER to project board."
                  fi

            - name: Prune Skills for Planning
              run: node tooling/ai-workers/prune-skills.js planning

            # 0.5 CHECKOUT TASK BRANCH (If exists)
            - name: Checkout Task Branch
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
              run: |
                  git config --global user.name "github-actions[bot]"
                  git config --global user.email "github-actions[bot]@users.noreply.github.com"
                  
                  echo "Searching for existing branch for Issue #$ISSUE_NUMBER..."
                  git fetch --all
                  
                  # Look for any branch starting with task/issue-NUMBER-
                  BRANCH_NAME=$(git branch -r | grep "origin/task/issue-$ISSUE_NUMBER-" | head -n 1 | sed 's/^[[:space:]]*//' | sed 's/origin\///')
                  
                  if [ -n "$BRANCH_NAME" ]; then
                    echo "Found existing branch: $BRANCH_NAME. Checking out..."
                    git checkout -b "$BRANCH_NAME" "origin/$BRANCH_NAME"
                    git pull --rebase origin "$BRANCH_NAME"
                    echo "current_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
                  else
                    echo "No existing branch found. Staying on main."
                    echo "current_branch=main" >> $GITHUB_OUTPUT
                  fi
              id: branch_context

            # 1. ATOMIC PLANNING
            - name: Planning
              id: planning
              env:
                  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
                  ISSUE_TITLE: ${{ steps.issue.outputs.title }}
                  ISSUE_BODY: ${{ steps.issue.outputs.body }}
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  CURRENT_BRANCH: ${{ steps.branch_context.outputs.current_branch }}
              run: node tooling/ai-workers/plan.js

            # 2. EXECUTION LOOP
            - name: Restore & Prune Skills for Development
              if: steps.planning.outputs.needs_decomposition != 'true'
              run: |
                  npx rulesync generate
                  node tooling/ai-workers/prune-skills.js development

            - name: Create or Switch to Feature Branch
              if: steps.planning.outputs.needs_decomposition != 'true'
              env:
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
                  PLANNED_BRANCH: ${{ steps.planning.outputs.branch_name }}
                  CURRENT_BRANCH: ${{ steps.branch_context.outputs.current_branch }}
              run: |
                  # If planning output a specific branch name, use it.
                  # Otherwise fall back to generic pattern.
                  TARGET_BRANCH="${PLANNED_BRANCH:-task/issue-$ISSUE_NUMBER-work}"
                  
                  echo "Target Branch: $TARGET_BRANCH"
                  echo "Current Branch: $CURRENT_BRANCH"

                  if [ "$CURRENT_BRANCH" == "$TARGET_BRANCH" ]; then
                    echo "Already on target branch."
                  else
                    echo "Switching to $TARGET_BRANCH..."
                    git checkout -b "$TARGET_BRANCH" || git checkout "$TARGET_BRANCH"
                  fi

            - name: Development & Implementation
              if: steps.planning.outputs.needs_decomposition != 'true'
              id: developer
              env:
                  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
                  ISSUE_TITLE: ${{ steps.issue.outputs.title }}
                  ISSUE_BODY: ${{ steps.issue.outputs.body }}
                  METHODOLOGY: ${{ steps.planning.outputs.methodology }}
                  FILES: ${{ steps.planning.outputs.files }}
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  PR_COMMENTS: ${{ steps.pr.outputs.pr_comments }}
                  ISSUE_COMMENTS: ${{ steps.issue.outputs.comments }}
              run: node tooling/ai-workers/develop.js

            - name: Finalize Work (Commit & Create PR)
              if: steps.planning.outputs.needs_decomposition != 'true'
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  COMMIT_MESSAGE: ${{ steps.developer.outputs.commit_message }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
                  REVIEWER_TEXT: ${{ steps.reviewer.outputs.json && fromJson(steps.reviewer.outputs.json).review_text || 'Reviewer Agent failed or was skipped.' }}
              run: |
                  # Use the user's git config if provided, otherwise fallback to bot
                  git config --global user.name "Jorge del Casar"
                  git config --global user.email "948953+jorgecasar@users.noreply.github.com"
                  
                  # Cleanup AI_COMMIT_MESSAGE file from disk
                  rm -f .github/AI_COMMIT_MESSAGE

                  # Check for uncommitted changes (fallback if agent failed to commit but work is done)
                  if [[ -n $(git status --porcelain) ]]; then
                    echo "Uncommitted changes detected. Committing..."
                    git add .
                    # Double check we didn't add the message file if it somehow persisted
                    git reset .github/AI_COMMIT_MESSAGE 2>/dev/null || true
                    
                    # Ensure MSG has the issue number
                    MSG="${COMMIT_MESSAGE:-feat: resolve #$ISSUE_NUMBER (AI Agent)}"
                    if [[ ! "$MSG" =~ "#$ISSUE_NUMBER" ]]; then
                      MSG="${MSG} (#$ISSUE_NUMBER)"
                    fi
                    git commit -m "$MSG"
                  fi
                  
                  # SQUASH COMMITS
                  # Get the message of the last commit (which should be the AI's conventional commit)
                  LAST_MSG=$(git log -1 --pretty=%s)
                  
                  # Ensure LAST_MSG has the issue number for the PR title
                  if [[ ! "$LAST_MSG" =~ "#$ISSUE_NUMBER" ]]; then
                    PR_TITLE="$LAST_MSG (#$ISSUE_NUMBER)"
                  else
                    PR_TITLE="$LAST_MSG"
                  fi
                  
                  # Soft reset to origin/main to stage all changes
                  git reset --soft origin/main
                  
                  # Ensure the temporary message file is NOT staged (if it was committed previously)
                  git reset HEAD .github/AI_COMMIT_MESSAGE 2>/dev/null || true
                  
                  # Commit everything as one atomic commit
                  git commit -m "$PR_TITLE"
                  
                  # Push changes
                  git fetch origin main
                  git pull --rebase origin main
                  git push --force-with-lease origin HEAD
                  
                  # Create Pull Request
                  gh pr create --title "$PR_TITLE" --body "Automated PR by AI Worker Agent. Resolves #$ISSUE_NUMBER. \n\nReviewer feedback: $REVIEWER_TEXT" || echo "PR creation failed or already exists"

            - name: Request Gemini Review
              if: steps.planning.outputs.needs_decomposition != 'true'
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
              run: |
                  # Find the PR for this branch
                  PR_NUMBER=$(gh pr list --head "$(git branch --show-current)" --json number --jq '.[0].number' 2>/dev/null || echo "")
                  if [ -n "$PR_NUMBER" ]; then
                    echo "Requesting Gemini review on PR #$PR_NUMBER..."
                    gh pr comment "$PR_NUMBER" --body "/gemini review"
                  else
                    echo "No PR found to request review on."
                  fi
                  
            # 3. VERIFICATION
            - name: Install Playwright Browsers
              if: steps.planning.outputs.needs_decomposition != 'true'
              run: npx playwright install --with-deps

            - name: Run Related Tests
              if: steps.planning.outputs.needs_decomposition != 'true'
              run: |
                  # Run tests with coverage
                  npx vitest run --coverage

            - name: Update Coverage Thresholds
              if: steps.planning.outputs.needs_decomposition != 'true'
              run: npm run test:coverage:update

            # 4. SELF-REVIEW
            - name: Self-Review
              if: steps.planning.outputs.needs_decomposition != 'true'
              id: reviewer
              uses: google-github-actions/run-gemini-cli@v0.1.20
              continue-on-error: true
              with:
                  gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
                  gemini_model: "gemini-2.5-flash"
                  prompt: |
                      You are the Reviewer Agent.
                      Role: @reviewer-agent

                      Files changed: $(git diff --name-only origin/main)
                      Diff:
                      $(git diff origin/main)

                      Instruction: Audit this code. Output a JSON object with a single key "review_text". The value should be "APPROVED" if quality is high, otherwise, it should be a string containing a list of issues.

            - name: Sync Costs
              if: always()
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
                  PLANNING_INPUT_TOKENS: ${{ steps.planning.outputs.input_tokens || '0' }}
                  PLANNING_OUTPUT_TOKENS: ${{ steps.planning.outputs.output_tokens || '0' }}
                  DEVELOPER_INPUT_TOKENS: ${{ steps.developer.outputs.input_tokens || '0' }}
                  DEVELOPER_OUTPUT_TOKENS: ${{ steps.developer.outputs.output_tokens || '0' }}
                  REVIEWER_INPUT_TOKENS: ${{ steps.reviewer.outputs.prompt_token_count || '0' }}
                  REVIEWER_OUTPUT_TOKENS: ${{ steps.reviewer.outputs.candidates_token_count || '0' }}
              run: |
                  node tooling/ai-workers/sync.js

            - name: Mark Task as Paused on Failure
              if: failure() || cancelled()
              env:
                  GH_TOKEN: ${{ secrets.GH_TOKEN }}
                  ISSUE_NUMBER: ${{ github.event.inputs.issue_number }}
              run: |
                  node tooling/ai-workers/sync.js --failed

            - name: Cleanup Temporary Files
              if: always()
              run: |
                  rm -f issue.json
